
#include "utils.h"
#include <sys/stat.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cstdio>
namespace FlowUtils
{

    /**
    * @brief Parses feature point pairs from the matches file generated by RAFT
    * @param matches_path matches file path
    * @param src_points Output source image feature points
    * @param dst_points Output destination image feature points
    */
    void parseMatchesFile(const std::string &matches_path,
                                          std::vector<cv::Point2f> &src_points,
                                          std::vector<cv::Point2f> &dst_points)
    {
        src_points.clear();
        dst_points.clear();

        std::ifstream file(matches_path);
        if (!file.is_open())
        {
            return;
        }

        std::string line;
        while (std::getline(file, line))
        {
            std::istringstream iss(line);
            float x0, y0, x1, y1;
            if (iss >> x0 >> y0 >> x1 >> y1)
            {
                src_points.emplace_back(x0, y0);
                dst_points.emplace_back(x1, y1);
            }
        }
        file.close();
    }

    void save_edge_dat(const cv::Mat &edge_map, const std::string &filename)
    {
        cv::Mat edge_float;
        if (edge_map.type() != CV_32F)
            edge_map.convertTo(edge_float, CV_32F);
        else
            edge_float = edge_map;

        if (edge_float.channels() > 1)
            cv::cvtColor(edge_float, edge_float, cv::COLOR_BGR2GRAY);
        std::cout << "[DEBUG] edge_float shape: " << edge_float.rows << "x" << edge_float.cols
                  << ", channels: " << edge_float.channels() << std::endl;

        std::ofstream ofs(filename, std::ios::binary);
        ofs.write(reinterpret_cast<const char *>(edge_float.data),
                  edge_float.rows * edge_float.cols * sizeof(float));
        ofs.close();

        std::cout << "[DEBUG] Saved edge.dat: " << edge_float.rows << "x" << edge_float.cols
                  << " = " << edge_float.total() << " floats" << std::endl;
    }

    // Replacement for cv::optflow::readOpticalFlow - reads .flo files
    cv::Mat readOpticalFlowFile(const std::string& path) 
    {
        std::ifstream file(path.c_str(), std::ios_base::binary);
        if (!file.good())
        {
            printf("Error opening flow file: %s\n", path.c_str());
            return cv::Mat();
        }

        float magic;
        file.read((char *)&magic, sizeof(float));
        if (magic != 202021.25f) // .flo file magic number
        {
            printf("Invalid .flo file magic number\n");
            return cv::Mat();
        }

        int width, height;
        file.read((char *)&width, sizeof(int));
        file.read((char *)&height, sizeof(int));

        cv::Mat flow(height, width, CV_32FC2);
        file.read((char *)flow.data, width * height * 2 * sizeof(float));
        file.close();

        return flow;
    }

    // Save the feature points as a txt file in RAFT format
    void savePointsToFile(const std::vector<cv::Point2f> &points, const std::string &filepath)
    {
        std::ofstream file(filepath);
        if (file.is_open())
        {
            for (const auto &point : points)
            {
                file << point.x << " " << point.y << "\n";
            }
            file.close();
            std::cout << "[DEBUG] Saved " << points.size() << " points to: " << filepath << std::endl;
        }
        else
        {
            std::cerr << "[ERROR] Failed to open file for writing: " << filepath << std::endl;
        }
    }

    /**
    * @brief Checks if a file exists and its timestamp is newer than the source file.
    */
    bool isFileUpToDate(const std::string &targetFile, const std::string &sourceFile)
    {
        std::ifstream f(targetFile);
        if (!f.good()) {
            return false;
        }
        f.close();

        // Get the file modification time
        struct stat targetStat, sourceStat;
        if (stat(targetFile.c_str(), &targetStat) != 0 || stat(sourceFile.c_str(), &sourceStat) != 0)
        {
            return false;
        }

        // The target file is considered the latest only if its timestamp is newer than the source file
        return targetStat.st_mtime >= sourceStat.st_mtime;
    }

    /**
    * @brief Check if the feature point cache is valid
    */
    bool isPointsCacheValid(const std::string &pointsFile, const std::string &imageFile)
    {
        return isFileUpToDate(pointsFile, imageFile);
    }

   /**
    * @brief Checks if the edge detection cache is valid
    */
    bool isEdgeCacheValid(const std::string &edgeFile, const std::string &imageFile)
    {
        return isFileUpToDate(edgeFile, imageFile);
    }

    /**
    * @brief Load cached feature points
    */
    std::vector<cv::Point2f> loadCachedPoints(const std::string &pointsFile)
    {
        std::vector<cv::Point2f> points;
        std::ifstream file(pointsFile);
        if (!file.is_open())
        {
            return points;
        }

        std::string line;
        while (std::getline(file, line))
        {
            std::istringstream iss(line);
            float x, y;
            if (iss >> x >> y)
            {
                points.emplace_back(x, y);
            }
        }
        file.close();
        return points;
    }

    bool callRAFTTCP_batch(
        const std::vector<std::string> &batch_img1_paths,
        const std::vector<std::string> &batch_img2_paths,
        const std::vector<std::string> &batch_points_paths,
        const std::vector<std::string> &batch_output_paths)
    {
        // Create a socket
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0)
        {
            std::cerr << "Socket creation failed for batch RAFT" << std::endl;
            return false;
        }

        // Increase the send buffer size
        int send_buffer_size = 4 * 1024 * 1024; 
        setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &send_buffer_size, sizeof(send_buffer_size));

        // Connect to the server
        struct sockaddr_in server_addr;
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(9998);
        inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);

        if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
        {
            std::cerr << "Batch RAFT TCP connection failed" << std::endl;
            close(sock);
            return false;
        }

        // Build batch JSON request
        Json::Value request;
        request["batch_mode"] = true;
        request["batch_size"] = (int)batch_img1_paths.size();

        // Use a more compact array construction method
        Json::Value img1_array(Json::arrayValue);
        Json::Value img2_array(Json::arrayValue);
        Json::Value points_array(Json::arrayValue);
        Json::Value output_array(Json::arrayValue);

        for (size_t i = 0; i < batch_img1_paths.size(); ++i)
        {
            img1_array.append(batch_img1_paths[i]);
            img2_array.append(batch_img2_paths[i]);
            points_array.append(batch_points_paths[i]);
            output_array.append(batch_output_paths[i]);
        }

        request["image1_paths"] = img1_array;
        request["image2_paths"] = img2_array;
        request["points_paths"] = points_array;
        request["output_paths"] = output_array;

        // Use FastWriter to reduce JSON size
        Json::FastWriter writer;
        std::string request_str = writer.write(request);

        // Make sure it ends with a newline character
        if (request_str.back() != '\n')
        {
            request_str += '\n';
        }

        std::cout << "[DEBUG] Sending batch RAFT request, size: " << request_str.length() << " bytes" << std::endl;

        // Send large data in chunks
        size_t total_sent = 0;
        size_t chunk_size = 8192;

        while (total_sent < request_str.length())
        {
            size_t to_send = std::min(chunk_size, request_str.length() - total_sent);
            ssize_t sent = send(sock, request_str.c_str() + total_sent, to_send, 0);

            if (sent < 0)
            {
                std::cerr << "Failed to send batch RAFT request" << std::endl;
                close(sock);
                return false;
            }

            total_sent += sent;
        }

        std::cout << "[DEBUG] Sent " << total_sent << " bytes to RAFT server" << std::endl;

        // Receive response
        std::string response_str;
        char buffer[4096];
        int bytes_received;
        int total_received = 0;
        int max_receive_size = 1024 * 1024; 

        while (total_received < max_receive_size)
        {
            bytes_received = recv(sock, buffer, sizeof(buffer), 0);

            if (bytes_received < 0)
            {
                std::cerr << "Failed to receive batch RAFT response" << std::endl;
                close(sock);
                return false;
            }

            if (bytes_received == 0)
            {
                break;
            }

            response_str.append(buffer, bytes_received);
            total_received += bytes_received;

    
            if (!response_str.empty() && response_str.back() == '\n')
            {
                break;
            }
        }

        close(sock);

        if (response_str.empty())
        {
            std::cerr << "Empty response from batch RAFT server" << std::endl;
            return false;
        }

        std::cout << "[DEBUG] Received response size: " << response_str.length() << " bytes" << std::endl;

        // Parse the response
        Json::Value response;
        Json::CharReaderBuilder reader_builder;
        std::istringstream response_stream(response_str);
        std::string parse_errors;

        if (!Json::parseFromStream(reader_builder, response_stream, &response, &parse_errors))
        {
            std::cerr << "Failed to parse batch RAFT response: " << parse_errors << std::endl;
            std::cerr << "Response preview: " << response_str.substr(0, 200) << "..." << std::endl;
            return false;
        }

        if (response["status"].asString() == "success")
        {
            std::cout << "[INFO] Batch RAFT TCP: " << response["message"].asString() << std::endl;
            return true;
        }
        else
        {
            std::cerr << "[ERROR] Batch RAFT TCP: " << response["message"].asString() << std::endl;
            return false;
        }
    }

    /**
    * @brief Batch InterpoNet TCP calls
    */
    bool callInterpoNetTCP_batch(
        const std::vector<std::string> &batch_img1_paths,
        const std::vector<std::string> &batch_img2_paths,
        const std::vector<std::string> &batch_edges_paths,
        const std::vector<std::string> &batch_matches_paths,
        const std::vector<std::string> &batch_output_paths)
    {
        // Create a socket
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0)
        {
            std::cerr << "Socket creation failed for batch InterpoNet" << std::endl;
            return false;
        }

        // Server address
        struct sockaddr_in server_addr;
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(9999); 
        inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);

        // Connect to the server
        if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
        {
            std::cerr << "Batch InterpoNet TCP connection failed" << std::endl;
            close(sock);
            return false;
        }

        // Build batch JSON request
        Json::Value request;
        request["batch_mode"] = true;
        request["batch_size"] = (int)batch_img1_paths.size();

        Json::Value img1_array(Json::arrayValue);
        Json::Value img2_array(Json::arrayValue);
        Json::Value edges_array(Json::arrayValue);
        Json::Value matches_array(Json::arrayValue);
        Json::Value output_array(Json::arrayValue);

        for (size_t i = 0; i < batch_img1_paths.size(); ++i)
        {
            img1_array.append(batch_img1_paths[i]);
            img2_array.append(batch_img2_paths[i]);
            edges_array.append(batch_edges_paths[i]);
            matches_array.append(batch_matches_paths[i]);
            output_array.append(batch_output_paths[i]);
        }

        request["img1_paths"] = img1_array;
        request["img2_paths"] = img2_array;
        request["edges_paths"] = edges_array;
        request["matches_paths"] = matches_array;
        request["output_paths"] = output_array;

        Json::FastWriter writer;
        std::string request_str = writer.write(request);
        if (request_str.back() != '\n')
        {
            request_str += '\n';
        }

        // Send the request
        send(sock, request_str.c_str(), request_str.length(), 0);

        // Receive response
        std::string response_str;
        char buffer[4096];
        int bytes_received;

        while ((bytes_received = recv(sock, buffer, sizeof(buffer), 0)) > 0)
        {
            response_str.append(buffer, bytes_received);
            if (!response_str.empty() && response_str.back() == '\n')
                break;
        }

        close(sock);

        if (bytes_received <= 0)
        {
            std::cerr << "Failed to receive batch InterpoNet response" << std::endl;
            return false;
        }

        // Parse the response
        Json::Value response;
        Json::CharReaderBuilder reader_builder;
        std::istringstream response_stream(response_str);
        std::string parse_errors;

        if (!Json::parseFromStream(reader_builder, response_stream, &response, &parse_errors))
        {
            std::cerr << "Failed to parse batch InterpoNet response: " << parse_errors << std::endl;
            return false;
        }

        if (response["status"].asString() == "success")
        {
            std::cout << "[INFO] Batch InterpoNet TCP: " << response["message"].asString() << std::endl;
            return true;
        }
        else
        {
            std::cerr << "[ERROR] Batch InterpoNet TCP: " << response["message"].asString() << std::endl;
            return false;
        }
    }

}